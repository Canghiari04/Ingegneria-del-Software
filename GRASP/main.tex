\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{titlesec}
\usepackage{enumitem}

\titleformat{\section}
{\LARGE\bfseries}{\thesection}{1em}{}

\titleformat{\subsection}
{\Large\bfseries}{\thesection}{1em}{}

\begin{document}
\pagestyle{empty}
\section*{GRASP}
\large

\subsection*{Introduzione}
\large
Obiettivi:
\begin{itemize}
    \renewcommand{\labelitemi}{-}
    \itemsep0em
    \item Definire che cos'è un pattern
    \item Comprendere quali siano i pattern che contraddistinguono GRASP
\end{itemize}
Il paragrafo esplicita quali siano i metodi affinchè i principi legati al paradigma orientato agli oggetti, inerenti alla qualità del software, possano essere concretamente attuati. Fino ad ora è stata adottata una definizione della semantica \textit{object design}, in cui si affermano una serie di passaggi, i quali adoperati sequenzialmente danno vita al risultato finale in grado di rispondere alla richiesta dei requisiti funzionali.\vspace*{14pt}\\
\textit{Definizione informale}\\
Pur di ottenere il processo esecutivo sperato occorre innanzitutto identificare i \textit{requisiti funzionali}, artefici della creazione del \textit{domain model} di riferimento, successivamente dovranno essere aggiunti i metodi che caratterizzino le differenti classi della soluzione, e infine definire come le stesse \textit{istanze} debbano comunicare per soddisfare la richiesta.\vspace*{14pt}\\
Tuttavia, questa breve descrizione non è di gran auspicio, dato che in qualsiasi step che la contraddistingue potrebbero sollervarsi problematiche e \textit{design smells}, peggiorando la qualità del software.\vspace*{14pt}\\
Per cui necessita uno strumento in grado di illustrare singole direttive capaci di approcciare un metodo impirico ad una progettazione legata agli oggetti, eliminando ogni grado di incertezza. Ciò è possibile attraverso l'implementazione dei \textit{pattern} del modello \textit{GRASP}.

\subsection*{Responsability}
\large
UML definisce una \textbf{responsabilità} come un \textit{contratto oppure obbligo di un classificatore}; per cui le \textit{responsabilità} sono relazionate ai vincoli comportamentali di un'istanza. Tipicamente sono suddivise in due macro-aree, le quali si contraddistinguono in:
\begin{itemize}[label={-}]
    \itemsep0em
    \item \textit{Doing}, responsabilità simili di un oggetto includono certi atteggiamenti come, operare per stessi termini, ossia creare un'istanza o processare un calcolo internamente, iniziazzare un'azione per ulteriori oggetti oppure controllare e gestire attività di altre istanze
    \item \textit{Knowing}, responsabilità simili di un oggetto illustrano una serie di comportamenti, quali, conoscere i dati incapsulati al suo interno, apprendere a quali oggetti sia relazionato oppure comprendere quali elementi possa derivare per proprie azioni
\end{itemize}
Per cui in breve le due tipologie possono essere riassunte come segue; \textit{doing responsabilities} permettono la realizzione di computazioni algoritmiche, mentre \textit{knowing responsabilities} prevedono di apprendere le informazioni interne ad ogni istanza di riferimento.\vspace*{14pt}\\
Una responsabilità non può essere paragonata ad un metodo, ma un metodo implementa responsabilità. Quest'ultimo inciso indica una caratterizzazione sottile, la quale può essere considerata mediante un \textit{activities diagram}. Si prenda come esempio il diagramma posto all'interno del capitolo \textit{design goal}; l'attore pur di apprendere il totale della spesa effettuata, demanda la richiesta alla classe \textit{saleManager}, il quale a sua volta, pur di ottenere l'informazione, reclama il valore alla classe \textit{sale}, contenente l'insieme di attributi e funzioni in grado di rispondere alla domanda.\vspace*{14pt}\\
Nonostante rappresenti una raffigurazione di estrema semplicità, si nota l'affermazione precedente, ossia i metodi implementano responsabilità, delegando la richiesta ad un elenco di istanze, fino a quando non si riscontri l'oggetto capace di soddisfare la domanda.\vspace*{14pt}\\
Un approccio dedicato all'assegnamento di responsabilità è denominato \textit{RDD}, ossia \textit{responsability driven design}. Quindi è un metodo per progettare sistemi software basato sulle responsabilità, in cui esse sono assegnate alle \textit{classi software} durante l'elaborazione. ...

\subsection*{GRASP}
\large
\textit{GRASP} è l'acronimo di \textit{General Responsability Assignment Software Pattern}, ossia descrive i principi fondamentali della progettazione ad oggetti e permette l'assegnazione di responsabilità, detti \textit{patterns}. Spesso è utilizzato per implementare gli aspetti salienti di \textit{RDD} ma garantendo una solida costruzione sui principi cardine. In ingegneria del software il paradigma introdotto è considerato come l'artefice del conseguimento in sistemi software di spessore, poichè permette di analizzare e comprendere gli elementi essenziali nella progettazione ad oggetti, applicando un approccio metodico, razionale e improntato alla massima espressività.\vspace*{14pt}\\
Prima di illustrare i differenti apici su cui è posto, è bene definire l'etimologia dell'espressione \textit{pattern}.\vspace*{14pt}\\
\textit{Definizione informale}\\
Un \textbf{pattern} è una soluzione generale ad un problema ricorrente.\vspace*{14pt}\\
Come da considerazione descritta dall'architetto Alexander, un qualsiasi \textit{pattern} illustrato considera un problema che occorre frequentemente all'interno di un ambiente, capace di associarne una soluzione, la quale può essere utilizzata con lo stesso metodo per cui sia stata già usata per risolvere correntemente la problematica ripetitiva. Riassumendo quanto detto, tramite il termine pattern, un problema ricorrente di medesima natura può essere risolto dalla stessa soluzione precedente.\vspace*{14pt}\\
Favorendo un'ulteriore chiave di lettura dal teorico Larman, un \textit{pattern}, per maggiore semplicità, rappresenta una descrizione nominativa di un problema e della sua soluzione correlata, indicando quando e come applicarla in nuovi contesti.\vspace*{14pt}\\
Introdotto il concetto su cui fonda l'intero contesto è possibile definire ora quali siano i pattern che contraddistringuono il modello \textit{GRASP}.

\subsection*{Patterns}
\large
Di seguito sono riportati i \textit{patterns} principali che contraddistinguono il modello \textit{GRASP}, in cui è attuata una suddivisione tra la definizione del problema e della soluzione correlata.\vspace*{14pt}\\
\textbf{Information expert}\vspace*{7pt}\\
\textit{Problema}\\
Come assegnare propriamente responsabilità alle istanze delle classi software.\vspace*{7pt}\\
UML potrebbe definire un numero sempre più elevato di responsabilità tra le classi, e lo stesso processo esecutivo potrebbe richiedere una quantità crescente di vincoli comportamentali. Buona pratica consiste nell'assegnare le \textit{responsabilities} tra \textit{software classes} durante la modellazione dell'interazioni tra oggetti; se eseguito correttamente il sistema tenderà ad essere più semplice da comprendere, mantenendo l'opportunità della qualità interna \textit{reusability}.\vspace*{14pt}\\ 
\textit{Soluzione}\\
La soluzione consiste nella sistematizzazione della classe software che acquisca la responsabilità. L'espressione riportata indica che l'assegnamento di responsability dovrebbe accadere nei confronti di classi già esistenti, scegliendo tra quelle che comprendano il numero maggiori di informazioni necessarie.\vspace*{14pt}\\
\textbf{Creator}\vspace*{7pt}\\
\textit{Problema}\\
Come scegliere chi dovrebbe essere il responsabile della creazione di nuove istanze di classi software.\vspace*{7pt}\\
La creazione di oggetti è una delle pratiche più comuni di un linguaggio legato al padarigma degli oggetti. Conseguentemente, sarebbe utile individuare un principio in grado di stabilire una responsabilità affine all'istenze di oggetti. Una correlazione corretta della Responsability potrebbe alludere ad una maggiore chiarezza sintattica e alla massimizzazione dell'\textit{incapsulazione} e della qualità \textit{reusability}.\vspace*{14pt}\\
\textit{Soluzione}\\
Adoperando una semplificazione semantica, l'assegnazione della responsabilità alla classe B, autrice della creazione di un'istanza della classe A, è corretta se rispettata almeno una delle condizioni seguenti:
\begin{itemize}[label={-}]
    \itemsep0em
    \item B aggrega, ossia contiene o compone, oggetti di A 
    \item B contiene oggetti di A 
    \item B utilizza fortemente oggetti di A
    \item B è in possesso di tutti i dati necessari per poter richiamare la funzione della classe software A, banalmente ha disposizione tutti gli attributi sufficienti per il metodo di destinazione
\end{itemize}
Nel caso più classi dovessero rispettare condizioni elencate, si tende a premiare effettività che comprendano le prime due caratteristiche illustrate.\vspace*{14pt}\\
\textbf{Controller}\vspace*{7pt}\\
\textit{Problema}\\
Come scegliere quale oggetto debba ricevere e coordinare un'operazione del sistema software.\vspace*{7pt}\\
Differenti sono i \textit{patterns} valutativi in cui possono essere presi in considerazione candidati piuttosto simili fra loro, in relazione alle classi poste all'interno del domain model. Il termine \textit{controller} è adottato proprio per esprimere una soluzione al problema; \textit{classi di controllo} potrebbero divenire uno strato posto tra classi di alto livello, quindi affini alla logica algoritmica, e classi di basso livello, per cui in relazione ad una raffigurazione dell'entità usufruibili dall'utente finale. L'utilizzo di uno scudo sovrapposto permette di isolare elementi dinamici, proprio come \textit{user interface}, le quali non devono mai interagire con classi prettamente legate allo sviluppo di metodi basici (\textit{si ricordi l'activity SaleManager all'interno del capitolo design goal, posto in mezzo alle attività UI e sale}).\vspace*{14pt}\\
\textit{Soluzione}\\
...\vspace*{14pt}\\
\end{document}                  
\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{titlesec}
\usepackage{enumitem}

\titleformat{\section}
{\LARGE\bfseries}{\thesection}{1em}{}

\titleformat{\subsection}
{\Large\bfseries}{\thesection}{1em}{}

\begin{document}
\pagestyle{empty}
\section*{Agile software development}
\large

\subsection*{Introduzione}
\large
Obiettivi:
\begin{itemize}
    \renewcommand{\labelitemi}{-}
    \itemsep0em
    \item Comprendere il giusto punto di equilibrio tra documentazione e sviluppo
\end{itemize}
Spesso attività di contorno potrebbero rappresentare processi fuorvianti rispetto alla concreto sviluppo del sistema software, nonostante siano fondamentali per la comprensione dei requisiti funzionali posti. Potrebbero essere visualizzate come \textit{pratiche burocratiche}, ossia l'insieme di elementi modellativi trattati non vengono mai sviluppati per ragioni legate alla costruzione del sistema software. A causa di questo elevato standard processuale non è riconducibile alcuna immediatezza tra la progettazione teorica e l'implementazione software, provocando una perdita della qualità.\vspace*{14pt}\\  
L'impegno dovuto a garantire coesione a livello strutturale comprende un vasto insieme di azioni, le quali potrebbero provocare un'elevata perdita di tempo qualora l'analisi adottata non sia ben chiara fin dall'inizio. Da cui ne deriva l'inutilità di una pianificazione perfetta, poichè l'intero contesto è soggetto a dinamicità, soprattutto un campo che riguardi lo sviluppo e la progettazione software.\vspace*{14pt}\\
Non solo il \textit{sistema software} dovrà essere flessibile ai cambiamenti, ma l'intero contesto sviluppato dovrà reagire prontamente a modifiche.

\subsection*{Manifesto per lo sviluppo agile}
\large
Il motivo che ha portato alla creazione del \textbf{manifesto}, è dovuto al netto spreco di risorse durante fasi di sviluppo software. Il termine correlato, \textit{Agile software development}, non deve essere considerato come un metodo di progettazione, ma rappresenta un insieme di \textit{pratiche} guidate da \textit{principi} e qualità sia \textit{interne} che \textit{esterne}. Attraverso il processo di analisi prodotto occorre valorizzare un insieme di prospettive, quali:
\begin{itemize}[label={-}]
    \itemsep0em
    \item Interazioni tra progettisti e sviluppatori al di sopra di processi sequenziali e strumenti tecnici
    \item Sviluppare e adoperare codice piuttosto che predilire una documentazione esaustiva
    \item Imbastire una collaborazione con il \textit{costumer}, denigrando una \textit{negoziazione} conflittuale
    \item Reagire prontamente a cambiamenti, evitando di sottostare alle linee guida originarie
\end{itemize}  
Il compito del \textit{manifesto} prevede di attribuire maggiore rilevanza all'entità poste alla sinistra dell'elenco, provando a descrivere un approccio che possa portare ad un concreto beneficio per progetti futuri, senza escludere un prossimo utilizzo di tutti gli elementi posti alla destra.

\subsection*{Principi}
\large
In relazione all'introduzione precedente, sono formulati di seguito i principi su cui stabilisce il proprio approccio il \textit{manifesto}, suddivisi in:
\begin{itemize}[label={-}]
    \itemsep0em
    \item La priorità principale richiede che il \textit{costumer} sia pienamente soddisfatto del risultato ottenuto, ciò può concretizzarsi solamente se sviluppatori optino per un continuo dialogo con i clienti e fornendo sequenzialmente versioni del sistema software implementato
    \item Reagire prontamente a modifiche e a variazioni di requisiti funzionali, sfruttando il cambiamento per ottenere vantaggio competitivo
    \item Valorizzare il \textit{lifecycle} del modello a spirale, il quale impone certe temporalità in cui richiedere confronti e discussioni
    \item Giornalmente sviluppatori e il \textit{business team} devono rendersi protagonisti nella realizzazione di task scelte
    \item Predilire il dialogo tra i singoli, poichè permette di diffondere in maniera efficiente ed efficace tutte le informazioni ritenute importanti
    \item Porre particolare attenzione a tecnologie abili ed eccellenti, relative non solo all'ambiente di sviluppo utilizzato, ma rispetto anche a novità progettuali o metodi differenti di cooperazione, pur di riuscire nell'intento della richiesta
    \item Adottare un approccio dedicato ad \textit{improvement}, che tendi a migliorare ad ogni passo, piuttosto che formalizzarsi sulla pianificazione dettagliata all'inizio della progettazione
\end{itemize}

\subsection*{Metodi agili}
\large
Esistono molte pratiche che adottano l'insieme dei principi descritti precedentemente, alcune delle quali sono in totale contraddizione, tuttavia proprio questa discordanza dovrebbe dare vita a un processo legato al continuo miglioramento, pur di aumentare la qualità di progettazione e sviluppo. Le metodologie si suddividono in:
\begin{itemize}[label={-}]
    \itemsep0em
    \item \textit{Code review}\vspace*{7pt}\\\textit{Definizione informale}\\Con il termine \textit{code review} si intende una pratica in cui una nuova porzione di codice deve essere analizzata e approvata prima di poter implementare nuove funzionalità.\vspace*{14pt}\\Come da definizione si adotta una revisione del codice affinchè possa essere poi incluso nella soluzione, da cui derivano un insieme di \textit{tool} che certificano la correttezza o meno. Uno dei principali bonus di questa pratica consiste nella maggiore efficacia della soluzione illustrata, poichè è analizzata da un numero crescente di sviluppatori i quali si accertano del \textit{code proposto}. Inoltre, adottando un approccio simile, si tende a condividere capacità e conoscenza, a causa della continua ricerca di nuove soluzioni legate a problemi che possano essere individuati conseguentemente ad azioni di \textit{review}. 
    \item \textit{Test-driven design}\vspace*{7pt}\\\textit{Definizione informale}\\Rappresenta uno stile di programmazione in cui tre attività si alternano, scrittura del \textit{codice}, \textit{test} della soluzione proposta ed infine \textit{progettazione}.\vspace*{14pt}\\\textit{Test driven design} può essere riassunto in un insieme di regole le quali prevedono un comportamento simile; innanzittutto si tende a descrivere le singole unità che indichino il processo esecutivo del sistema, per poi inizializzare la fase di testing, dove con molta probabilità, trattandosi di una stesura iniziale, sarà carente di specifiche. Per superare l'errore si cerca di scrivere il codice più semplice possibile, che possa garantire la correttezza del test, anche se potrebbe comportare a soluzioni non adeguate. Infine, si attua \textit{refactoring} del codice affinchè sia comprensibile e riutilizzabile; terminato, si ripete l'intero comportamento per ulteriori funzioni.
    \item \textit{User stories}\vspace*{7pt}\\\textit{Definizione informale}\\Indica un'illustrazione differente dei requisiti funzionali.\vspace*{14pt}\\Spesso sono espressioni scritte nel linguaggio del dominio che servono a catturare le aspettative dell'utente, per cui in grado di poter indirizzare lo sviluppo software. Molte \textit{agile software development} tendono ad adottare \textit{user stories} per rappresentare i requisiti, i quali non devono essere confusi con la progettazione modellativa posta da \textit{use case}. Semplicemente, la propria sintassi prevede una costruzione come segue: \begin{itemize}[label={ }, leftmargin=1cm] \item \textit{As a <role>, I want <goal> so that <benefit>}\end{itemize} Ultima nota stabilisce il corretto uso del costrutto, in quanto deve essere più specifico possibile, altrimenti perderebbe di utilità, e garantire una stesura che promuova prima la descrizione dell'obiettivo per poi illustare il valore raggiungibile.
\end{itemize}

\subsection*{INVEST}
\large
\textit{User stories} rappresenta uno dei \textit{agile software development} di maggiore uso, dove ad un primo impatto potrebbe essere di facile uso e implementazione; tuttavia, la propria complessità comincia ad emergere di pari passo all'aumento della struttura del sistema software. Per questa difficoltà crescente si adottano strumenti per comprendere la qualità e l'efficacia delle \textit{user stories}. I criteri sono riassunti come:
\begin{itemize}[label={-}]
    \itemsep0em
    \item \textit{Indipendente}, ogni user story non dovrebbe dipendere da nessun altro elemento. Ciò potrebbe accadere qualora siano descritte user stories che illustrino un livello tecnico molto specifico, attuando sottili caratteristiche.
    \item \textit{Negoziabile}, le user stories non possono essere intese al pari di contratti. Anzi la loro natura è il risultato di una \textit{negoziazione}, il quale è sottoposto in un qualsiasi momento a nuove rivalutazioni
    \item \textit{Valorizzabile}, come già accennato nell'introduzione, qualsiasi user story deve portare da un obiettivo ad un risultato \textit{valorizzabile}
    \item \textit{Stimabile}, il team di sviluppo dovrebbe apprendere il livello di complessità e la totalità del lavoro che caratterizza la user story realizzata
    \item \textit{Piccola}, illustrando una realtà apparentemente minuta, che contraddistingue un'unica funzionalità, essa deve essere eleborata in una sola \textit{iterazione}. Al termine del processo esecutivo, la funzionalità elaborata è considerata conclusa. Qualora non siano di piccola dimensione, per cui ritraendo problematiche di spessore, si attua la strategia dei \textit{pattern}, in relazione ad una particolare avversità si adotta una soluzione ricorrente, anche se essa non prevede un uso di codice semplice e non articolato
    \item \textit{Testabile}, indica uno dei punti cardine dei \textit{metodi agili}, in cui l'implementazione di una user story è conclusa solamente quando è conforme al \textit{test di accesso}. Qualora non sia verificata la conformità allora la progettazione della funzionalità non può essere ritenuta terminata
\end{itemize}
\end{document}
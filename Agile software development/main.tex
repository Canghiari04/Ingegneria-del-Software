\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lipsum}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[margin=1in]{geometry}
\usepackage{titlesec}
\usepackage{enumitem}

\titleformat{\section}
{\LARGE\bfseries}{\thesection}{1em}{}

\titleformat{\subsection}
{\Large\bfseries}{\thesection}{1em}{}

\begin{document}
\pagestyle{empty}
\section*{Agile software development}
\large

\subsection*{Introduzione}
\large
Obiettivi:
\begin{itemize}
    \renewcommand{\labelitemi}{-}
    \itemsep0em
    \item Comprendere il giusto punto di equilibrio tra documentazione e sviluppo
\end{itemize}
Spesso attività di contorno potrebbero rappresentare processi fuorvianti rispetto alla concreto sviluppo del sistema software, nonostante siano fondamentali per la comprensione dei requisiti funzionali posti. Potrebbero essere visualizzate come \textit{pratiche burocratiche}, ossia l'insieme di elementi modellativi trattati non vengono mai sviluppati per ragioni legate alla costruzione del sistema software. A causa di questo elevato standard processuale non è riconducibile alcuna immediatezza tra la progettazione teorica e l'implementazione software, provocando una perdita della qualità.\vspace*{14pt}\\  
L'impegno dovuto a garantire coesione a livello strutturale comprende un vasto insieme di azioni, le quali potrebbero provocare un'elevata perdita di tempo qualora l'analisi adottata non sia ben chiara fin dall'inizio. Da cui ne deriva l'inutilità di una pianificazione perfetta, poichè l'intero contesto è soggetto a dinamicità, soprattutto un campo che riguardi lo sviluppo e la progettazione software.\vspace*{14pt}\\
Non solo il \textit{sistema software} dovrà essere flessibile ai cambiamenti, ma l'intero contesto sviluppato dovrà reagire prontamente a modifiche.

\subsection*{Manifesto per lo sviluppo agile}
\large
Il motivo che ha portato alla creazione del \textbf{manifesto}, è dovuto al netto spreco di risorse durante fasi di sviluppo software. Il termine correlato, \textit{Agile software development}, non deve essere considerato come un metodo di progettazione, ma rappresenta un insieme di \textit{pratiche} guidate da \textit{principi} e qualità sia \textit{interne} che \textit{esterne}. Attraverso il processo di analisi prodotto occorre valorizzare un insieme di prospettive, quali:
\begin{itemize}[label={-}]
    \itemsep0em
    \item Interazioni tra progettisti e sviluppatori al di sopra di processi sequenziali e strumenti tecnici
    \item Sviluppare e adoperare codice piuttosto che predilire una documentazione esaustiva
    \item Imbastire una collaborazione con il \textit{costumer}, denigrando una \textit{negoziazione} conflittuale
    \item Reagire prontamente a cambiamenti, evitando di sottostare alle linee guida originarie
\end{itemize}  
Il compito del \textit{manifesto} prevede di attribuire maggiore rilevanza all'entità poste alla sinistra dell'elenco, provando a descrivere un approccio che possa portare ad un concreto beneficio per progetti futuri, senza escludere un prossimo utilizzo di tutti gli elementi posti alla destra.

\subsection*{Principi}
\large
In relazione all'introduzione precedente, sono formulati di seguito i principi su cui stabilisce il proprio approccio il \textit{manifesto}, suddivisi in:
\begin{itemize}[label={-}]
    \itemsep0em
    \item La priorità principale richiede che il \textit{costumer} sia pienamente soddisfatto del risultato ottenuto, ciò può concretizzarsi solamente se sviluppatori optino per un continuo dialogo con i clienti e fornendo sequenzialmente versioni del sistema software implementato
    \item Reagire prontamente a modifiche e a variazioni di requisiti funzionali, sfruttando il cambiamento per ottenere vantaggio competitivo
    \item Valorizzare il \textit{lifecycle} del modello a spirale, il quale impone certe temporalità in cui richiedere confronti e discussioni
    \item Giornalmente sviluppatori e il \textit{business team} devono rendersi protagonisti nella realizzazione di task scelte
    \item Predilire il dialogo tra i singoli, poichè permette di diffondere in maniera efficiente ed efficace tutte le informazioni ritenute importanti
    \item Porre particolare attenzione a tecnologie abili ed eccellenti, relative non solo all'ambiente di sviluppo utilizzato, ma rispetto anche a novità progettuali o metodi differenti di cooperazione, pur di riuscire nell'intento della richiesta
    \item Adottare un approccio dedicato ad \textit{improvement}, che tendi a migliorare ad ogni passo, piuttosto che formalizzarsi sulla pianificazione dettagliata all'inizio della progettazione
\end{itemize}

\subsection*{Metodi agili}
\large
Esistono molte pratiche che adottano l'insieme dei principi descritti precedentemente, alcune delle quali sono in totale contraddizione, tuttavia proprio questa discordanza dovrebbe dare vita a un processo legato al continuo miglioramento, pur di aumentare la qualità di progettazione e sviluppo. Le metodologie si suddividono in:
\begin{itemize}[label={-}]
    \itemsep0em
    \item \textit{Code review}\vspace*{7pt}\\\textit{Definizione informale}\\Con il termine \textit{code review} si intende una pratica in cui una nuova porzione di codice deve essere analizzata e approvata prima di poter implementare nuove funzionalità.\vspace*{14pt}\\Come da definizione si adotta una revisione del codice affinchè possa essere poi incluso nella soluzione, da cui derivano un insieme di \textit{tool} che certificano la correttezza o meno. Uno dei principali bonus di questa pratica consiste nella maggiore efficacia della soluzione illustrata, poichè è analizzata da un numero crescente di sviluppatori i quali si accertano del \textit{code proposto}. Inoltre, adottando un approccio simile, si tende a condividere capacità e conoscenza, a causa della continua ricerca di nuove soluzioni legate a problemi che possano essere individuati conseguentemente ad azioni di \textit{review}. 
    \item \textit{Test-driven design}\vspace*{7pt}\\\textit{Definizione informale}\\Rappresenta uno stile di programmazione in cui tre attività si alternano, scrittura del \textit{codice}, \textit{test} della soluzione proposta ed infine \textit{progettazione}.\vspace*{14pt}\\\textit{Test driven design} può essere riassunto in un insieme di regole le quali prevedono un comportamento simile; innanzittutto si tende a descrivere le singole unità che indichino il processo esecutivo del sistema, per poi inizializzare la fase di testing, dove con molta probabilità, trattandosi di una stesura iniziale, sarà carente di specifiche. Per superare l'errore si cerca di scrivere il codice più semplice possibile, che possa garantire la correttezza del test, anche se potrebbe comportare a soluzioni non adeguate. Infine, si attua \textit{refactoring} del codice affinchè sia comprensibile e riutilizzabile; terminato, si ripete l'intero comportamento per ulteriori funzioni.
    \item \textit{User stories}\vspace*{7pt}\\\textit{Definizione informale}\\Indica un'illustrazione differente dei requisiti funzionali.\vspace*{14pt}\\Spesso sono espressioni scritte nel linguaggio del dominio che servono a catturare le aspettative dell'utente, per cui in grado di poter indirizzare lo sviluppo software. Molte \textit{agile software development} tendono ad adottare \textit{user stories} per rappresentare i requisiti, i quali non devono essere confusi con la progettazione modellativa posta da \textit{use case}. Semplicemente, la propria sintassi prevede una costruzione come segue: \begin{itemize}[label={ }, leftmargin=1cm] \item \textit{As a <role>, I want <goal> so that <benefit>}\end{itemize} Ultima nota stabilisce il corretto uso del costrutto, in quanto deve essere più specifico possibile, altrimenti perderebbe di utilità, e garantire una stesura che promuova prima la descrizione dell'obiettivo per poi illustare il valore raggiungibile.
\end{itemize}

\subsection*{INVEST}
\large
\textit{User stories} rappresenta uno dei \textit{agile software development} di maggiore uso, dove ad un primo impatto potrebbe essere di facile uso e implementazione; tuttavia, la propria complessità comincia ad emergere di pari passo all'aumento della struttura del sistema software. Per questa difficoltà crescente si adottano strumenti per comprendere la qualità e l'efficacia delle \textit{user stories}. I criteri sono riassunti come:
\begin{itemize}[label={-}]
    \itemsep0em
    \item \textit{Indipendente}, ogni user story non dovrebbe dipendere da nessun altro elemento. Ciò potrebbe accadere qualora siano descritte user stories che illustrino un livello tecnico molto specifico, attuando sottili caratteristiche.
    \item \textit{Negoziabile}, le user stories non possono essere intese al pari di contratti. Anzi la loro natura è il risultato di una \textit{negoziazione}, il quale è sottoposto in un qualsiasi momento a nuove rivalutazioni
    \item \textit{Valorizzabile}, come già accennato nell'introduzione, qualsiasi user story deve portare da un obiettivo ad un risultato \textit{valorizzabile}
    \item \textit{Stimabile}, il team di sviluppo dovrebbe apprendere il livello di complessità e la totalità del lavoro che caratterizza la user story realizzata
    \item \textit{Piccola}, illustrando una realtà apparentemente minuta, che contraddistingue un'unica funzionalità, essa deve essere eleborata in una sola \textit{iterazione}. Al termine del processo esecutivo, la funzionalità elaborata è considerata conclusa. Qualora non siano di piccola dimensione, per cui ritraendo problematiche di spessore, si attua la strategia dei \textit{pattern}, in relazione ad una particolare avversità si adotta una soluzione ricorrente, anche se essa non prevede un uso di codice semplice e non articolato
    \item \textit{Testabile}, indica uno dei punti cardine dei \textit{metodi agili}, in cui l'implementazione di una user story è conclusa solamente quando è conforme al \textit{test di accesso}. Qualora non sia verificata la conformità allora la progettazione della funzionalità non può essere ritenuta terminata
\end{itemize}

\subsection*{Agile and evolution}
\large
Come già descritto, spesso in un team di sviluppo si tende ad utilizzare la maggior parte del tempo a disposizione e delle risorse per rendere esaustiva la documentazione relativa al sistema software che dovrà essere implementato. Tuttavia tale approccio tende a soffermarsi su \textit{questioni burocratiche}, accantonando il vero sviluppo software legato ai requisiti funzionali.\vspace*{14pt}\\
Per cui lo \textit{sviluppo} rappresenta una fase fondamentale ma non sufficiente per completare il lifecycle del sistema software; occorre promuovere un'evoluzione della soluzione attuata, affinchè sia garantito un comportamento adattivo che si adegui a possibili modifiche oppure ad aggiunte di funzionalità.\vspace*{14pt}\\
La metodica \textbf{agile-evolution} raffigura una modalità che ovvia alla costringente stesura di documentazione, focalizzandosi sulla condivisione della conoscenza acquisita durante fasi di implementazione del codice, mediante la scrittura di un \textit{piccolo archivio}.\vspace*{14pt}\\
La realizzazione della documentazione deve avvenire al di fuori delle fasi prestabilite per l'implementazione del codice, con l'elevata probabilità che la stesura dell'archivio non venga mai effettivamente concretizzata. Ciò non rappresenta una mancanza di estrema importanza, poichè in \textit{agile software development} le informazioni di spessore sono veicolate tramite il dialogo, ponendo in secondo luogo la documentazione, anche se una totale assenza di uno storico relativo al lavoro svolto potrebbe provocare difficoltà qualora il progetto software sia demandato ad altri team di sviluppo.

\subsection*{Extreme programming}
\large
\textbf{Extreme programming} è una metodologia agile ideata dal teorico \textit{Beck}, personaggio che nel panorama della materia trattata capì l'importanza delle dipendenze all'interno dello sviluppo di un sistema software. Per certi aspetti è molto simile al \textit{manifesto agile}, ma provvede a focalizzarsi su ulteriori caratterizzazioni.\vspace*{14pt}\\
\textit{XP} tende a valorizzare attività che ovviano alla stesura di una documentazione dettagliata, ponendo maggiore importanza sulla concreta implementazione della soluzione. Per cui sono imposti all'interno del team atteggiamenti che ritraggono il dialogo tra gli sviluppatori, la scrittura del codice oppure la progettazione di soluzioni inerenti a problemi sorti.\vspace*{14pt}\\
Si fonda, come da descrizione precedente, su valori legati alla comunicazione all'interno del team di sviluppo, all'adozione di soluzioni più semplici possibili affinchè sia possibile superare l'ostacolo ed infine alla responsabilizzazione di ogni componente del gruppo, rendendolo partecipe attivamente alla progettazione del sistema software; tuttavia per rendere concreto ciò che è stato trattato, occorre attuare una serie di principi che contraddistinguono \textit{extreme programming}, suddivisi come segue:
\begin{itemize}[label={-}]
    \item \textit{Fine scale feedback}\vspace*{7pt}\\
    \textit{Definizione informale}\\
    Fine scale feedback ammette che qualsiasi decisione strutturale deve essere condivisa da tutto il team di sviluppo.\vspace*{7pt}\\
    Per cui sono adottate metodologie relative alla definizione precedente, quali:
    \begin{itemize}
        \item \textit{Pair programming}, la stesura delle funzionalità è affidata a due entità del gruppo di sviluppo, dove tendenzialmente avviene uno scambio di mansioni tra le due figure, come la scrittura del codice e l'analisi della soluzione proposta
        \item \textit{Test driven development}, si attuano fasi di test dello sviluppo adeguato fino a un dato momento, in cui, qualora siano verificate anomalie, occorre sviluppare la soluzione più semplice possibile, a cui, successivamente, si adattano attività di refactoring
        \item \textit{Whole team}, all'interno del team non devono esistere suddivisioni nette tra i membri, e ognuno di essi deve acquisire le competenze necessarie per cimentarsi in qualsiasi sezione dello sviluppo del software
    \end{itemize}
    Concludendo, tramite questo principio, è imposta la coesione tra ogni elemento del team, in cui si tende a valorizzare la partecipazione di ognuno di essi nell'ambito decisionale e progettuale del sistema software attuato.
    \item \textit{Continuos process}\vspace*{7pt}\\
    \textit{Definizione informale}\\
    ...\vspace*{7pt}\\
    Nuovamente sono introdotte ulteriori pratiche che contraddistinguono \textit{continuos process}, suddivise come:
    \begin{itemize}
        \item \textit{Continuos integration}, qualora siano attuate delle modifiche, occorre che siano riportate immediatamente all'interno della soluzione del \textit{code base}, dove il termine proposto indica l'insieme di punti necessari per ottenere la soluzione software
        \item \textit{Design improvement}, la stesura di risoluzioni semplici a problemi sorti non deve accontanare l'attività di \textit{refactoring}, poichè potrebbero rappresentare una situazione di \textit{debito tecnico}
        \item \textit{Small releases}, adeguare lo sviluppo software affinchè sia possibile rilasciare versioni del sistema monitorabili e analizzabili, affinchè ciò si possa tradurre in un vantaggio competitivo e dichiarare se la progettazione attuata sia conforme con \textit{user stories}, oppure semplicemente con i requisiti funzionali dell'utente finale
    \end{itemize}
    \item \textit{Shared understanding}\vspace*{7pt}\\
    Principio che comprende:
    \begin{itemize}
        \item \textit{Coding standard}, opportuno che siano definiti paradigmi di progettazione e sviluppo equivalenti per ogni membro del team 
        \item \textit{Simple design}, processo esecutivo equivalente a \textit{test driven design}, ossia verificate anomalie si sviluppano soluzioni di estrema semplicità, a cui si adeguano attività di \textit{refactoring} affinchè si possa eliminare il \textit{debito tecnico} 
        \item \textit{System metaphor}, in certi contesti, potrebbe rappresentare una buona idea l'utilizzo di termini, all'interno della soluzione proposta, correlati al linguaggio del domonio, ossia rendere la tematica comprensibile anche per attori posti al di fuori del team di sviluppo, nonostante spesso è raffigurato come un principio di scarsa importanza, poichè non influisce direttamente sull'implementazione dei requisiti funzionali
    \end{itemize}
    \item \textit{Programmer welfare}\vspace*{7pt}\\
    \textit{Definizione informale}\\
    \textit{Programmer welfare} pone la propria centralità sul lavoro e sviluppo cooperativo, affinchè l'implementazione del sistema software sia suddivisa in \textit{time box}, alludendo ad un progetto che debba essere svolto a step e valorizzando le interazioni tra membri del gruppo, racchiudendo l'intero contesto su cui si formula \textit{extreme programming}.
\end{itemize}
\end{document}